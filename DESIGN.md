﻿##Title and Character Selection ScreensThe title screen is simply a series of print statements writing the title and the controls of the game, where enter moves the game to the next gamestate, the selection screen. The character selection screen is made using the Player class and print statements that write the direction. The program draws the sprite of the first player in four different positions, changing which sprite document it draws from every time, to represent the four playable characters. Meanwhile, the game keeps track of the most recent key corresponding to each character skin for each player, and changes what sprite the Player and Player2 classes use accordingly, and draws the cursor for each player under the skin accordingly (defaulting to skin one for player one and skin two for player two). Enter again changes the gamestate to the ready to fight screen.##Game mechanics One of the most important parts that we wanted to do is institute a special move for each character. A “concentration commando” wouldn’t be a “concentration commando” if they didn’t have their own special abilities. As explained in the README, STEM shoots a slow laser, Humanities throws a book in an arc, Econ holds out a snake and David Malan as a dash. The general idea for each projectile character is the same. Each projectile is not a class in it of itself, it is an object within each player class. So we create a table that essentially tracks the projectiles. In order to ensure that the mechanics regarding shooting such as velocity and direction function properly, we have a table for both right and left projectiles. So the table is tracks objects by drawing them, updating them, and using timers to allow when each player is allowed to fire. So for each player class and each direction that a player can shoot, there is a designated table. So when the correct button is pressed (and other conditions are met for gameplay), a new bullet is created, it is inserted into the table, the timer conditions are reset and the projectile sound is played. When a new object for the projectile is created, it starts at the player’s y position and slightly offset from the player’s x position. After this, there is a for loop that iterates through each bullet to keep updating its position. The reason we use ipairs is because for the loop it looks at the bullet object and its index and ipairs returns these values for the loop. For each projectile, the equation may be a little different regarding the exact way each projectile is updated (in a line, in an arc, or stationary). There is also a condition (since some projectiles only allow one at a time) that ensures if a projectile exits the screen it is removed from the table. This ensures we aren’t wasting memory or processes on loading needless projectiles.Then in map update, we look at projectile collisions to make sure that we actually register when someone’s special attack hits. We first put an initial collision function that essentially takes the bounding boxes for two objects (player and projectile) and sees if they overlap in any way. So each projectile object (left and right side for each player and each projectile) has its own function in Map that checks the collision between the player and each object in the projectile table by iterating through the table using ipairs again. Then if a collision is detected, it increments score and resets the game. Finding out the best way to implement collisions, effectively and efficiently, was one of the hardest tasks of the project. We were unsure if we needed to put it in map, class or main or anything else. In the end, I think map was the best decision because it allows us to reference both player classes and update them in map update without bogging down the main.lua code. We were also struggling with how to check each bullet in the table, but we were able to gain some insight from other game projects online.##OtherExtraneous implementation such as loading graphics and sounds are just preloaded and then called when necessary. We also ensured that the Victory Screen music pauses the regular background music. 